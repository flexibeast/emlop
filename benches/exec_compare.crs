#!/usr/bin/env run-cargo-script
//! Quick script to benchmark *lop implementations.
//!
//! ```cargo
//! [dependencies]
//! clap = "*"
//! stats-cli = "*"
//! tabwriter = "*"
//! ```

#[macro_use] extern crate clap;
extern crate inc_stats;
extern crate tabwriter;

use clap::{App, AppSettings, Arg};
use inc_stats::*;
use std::{collections::{BTreeMap, HashMap}, fs::File, io, io::Write, process::{Command, Stdio}, time::Instant};
use tabwriter::TabWriter;

fn main() {
    // Test definitions: (program name, test suite, stdin, program args)
    let tests: Vec<(&str,&str,Option<&str>,&[&str])> = vec![
        ("genlop","h",None,&["-h"]),
        ("qlop",  "h",None,&["-h"]),
        ("emlop", "h",None,&["-h"]),
        ("pqlop", "h",None,&["-h"]),
        ("golop", "h",None,&["-h"]),

        ("genlop","l",None,&["-l"]),
        ("qlop",  "l",None,&["-l"]),
        ("emlop", "l",None,&["l"]),
        ("golop", "l",None,&["golop"]),

        ("genlop","lf",None,&["-l","-f","test/emerge.10000.log"]),
        ("qlop",  "lf",None,&["-l","-f","test/emerge.10000.log"]),
        ("emlop", "lf",None,&["l", "-f","test/emerge.10000.log"]),
        ("golop", "lf",None,&["-l","test/emerge.10000.log"]),

        ("emlop", "lc",None,&["l", "--color=y"]),
        ("genlop","ln",None,&["-l","-n"]),
        ("qlop",  "ln",None,&["-l","--nocolor"]),
        ("emlop", "ln",None,&["l", "--color=n"]),

        ("genlop","tgcc",None,&["-t","gcc"]),
        ("qlop",  "tgcc",None,&["-g","gcc"]),
        ("emlop", "tgcc",None,&["l", "gcc","-e"]),
        ("pqlop", "tgcc",None,&["-g","gcc"]),
        ("golop", "tgcc",None,&["-t","gcc"]),

        ("genlop","egcc",None,&["-e","gcc"]),
        ("qlop",  "egcc",None,&["-l","gcc"]),
        ("emlop", "egcc",None,&["l", "gcc","-e"]),
        ("pqlop", "egcc",None,&["-g","gcc"]),
        ("golop", "egcc",None,&["-t","gcc"]),

        ("genlop","c",None,&["-c"]),
        ("qlop",  "c",None,&["-c"]),
        ("emlop", "c",None,&["p"]),
        ("pqlop", "c",None,&["-c"]),
        ("golop", "c",None,&["-c"]),

        ("genlop","pgcc",Some("benches/emerge-p.gcc.out"),&["-p"]),
        ("emlop", "pgcc",Some("benches/emerge-p.gcc.out"),&["p"]),
        ("genlop","pqt", Some("benches/emerge-p.qt.out"), &["-p"]),
        ("emlop", "pqt", Some("benches/emerge-p.qt.out"), &["p"]),
        ("genlop","pkde",Some("benches/emerge-p.kde.out"),&["-p"]),
        ("emlop", "pkde",Some("benches/emerge-p.kde.out"),&["p"]),
    ];

    // CLI definition
    let mut allsuites: Vec<&str> = tests.iter().map(|&(_,s,_,_)| s).collect();
    allsuites.sort();
    allsuites.dedup();
    let allsuites_str = allsuites.join(",");
    let cli = App::new("emlop-bench")
        .about("Quick script to benchmark *lop implementations.")
        .global_setting(AppSettings::ColoredHelp)
        .global_setting(AppSettings::DeriveDisplayOrder)
        .after_help("All benchmarks are biased. Some tips to be less wrong:\n\
 * Make your system is as idle as possible, shutdown unneeded apps (browser, im, cron...).\n\
 * Don't compare numbers collected at different times or on different machines.\n\
 * Look at all indicators, not just the mean.\n\
 * The terminal emulator's speed makes a big difference. Reduce the scroll buffer size and check performance-related settings.\n\
 * Use -n option (redirect to /dev/null) to ignore terminal overhead.\n\
 * Pipe to cat to disable colors (see also color-specific suites).")
        .arg(Arg::with_name("programs")
             .help("Test programs, formated as 'NAME[:PATH][,...]' (coma-separated list of program \
name and optional program path, eg 'emlop,emlop:./target/release/emlop,qlop')")
             .short("p")
             .takes_value(true)
             .multiple(true)
             .use_delimiter(true)
             .default_value("emlop"))
        .arg(Arg::with_name("suites")
             .help("Test suites")
             .short("s")
             .takes_value(true)
             .multiple(true)
             .use_delimiter(true)
             .possible_values(&allsuites)
             .hide_possible_values(true)
             .default_value(&allsuites_str))
        .arg(Arg::with_name("runs")
             .help("Number of iterations")
             .short("r")
             .takes_value(true)
             .default_value("10"))
        .arg(Arg::with_name("samples")
             .help("Only show first N samples in the final output")
             .short("S")
             .takes_value(true)
             .default_value("25"))
        .arg(Arg::with_name("nullout")
             .short("n")
             .help("Send test program outputs to /dev/null"))
        .get_matches();

    // CLI parsing
    let runs = value_t!(cli, "runs", usize).unwrap();
    let samples = value_t!(cli, "samples", usize).unwrap();
    let progs = values_t!(cli.values_of("programs"), String).unwrap();
    let suites = values_t!(cli.values_of("suites"), String).unwrap();
    let nullout = cli.is_present("nullout");

    // Construct the test list. We abuse the hashmap behavior to run tests in random order.
    let mut mytests = HashMap::<usize,(String,Option<&str>,&str,&[&str])>::new();
    let mut n = 0;
    for p in progs.iter() {
        let (p1,mut p2) = p.split_at(p.find(':').unwrap_or(p.len()));
        p2 = match p2.is_empty() {
            true => p1,
            false => p2.trim_left_matches(':'),
        };
        let tests: Vec<_> = tests.iter().filter(|&(t,s,_,_)| t == &p1 && suites.contains(&s.to_string())).collect();
        if tests.is_empty() {
            writeln!(io::stderr(), "No test defined for program '{}' and suites '{}' !", p1, suites.join(",")).unwrap();
        }
        for &(_,su,si,ar) in tests {
            for _ in 0..runs {
                mytests.insert(n,(format!("{}\t{}",su,p2), si, p2, ar));
                n += 1;
            }
        }
    }

    // Load /var/log/emerge.log in the OS cache
    assert_eq!(0, Command::new("cat")
               .arg("/var/log/emerge.log")
               .stdout(Stdio::null())
               .status().unwrap().code().unwrap());

    // Run the tests and collect the results
    let mut times: BTreeMap<String,Vec<f64>> = BTreeMap::new();
    for (name,stdin,bin,args) in mytests.values() {
        match nullout {
            true => write!(io::stderr(), "\r{} ", n).unwrap(),
            false => writeln!(io::stderr(), "{}: {} {}{}", n, bin, args.join(" "), stdin.map_or(String::new(), |f| format!(" < {}", f))).unwrap(),
        };
        n -= 1;
        let timevec = times.entry(name.clone()).or_insert(vec![]);
        let si = match stdin {
            None => Stdio::inherit(),
            Some(f) => File::open(f).unwrap().into()
        };
        let so = match nullout {
            true => Stdio::null(),
            false => Stdio::inherit(),
        };
        let start = Instant::now();
        Command::new(bin)
            .args(args.into_iter())
            .stdin(si)
            .stdout(so)
            .status()
            .expect(&format!("Couldn't run {} {:?}", bin, args));
        let elapsed = start.elapsed();
        timevec.insert(0, (elapsed.as_secs()*1000 + elapsed.subsec_nanos() as u64 / 1_000_000) as f64);
    }

    // Output the results
    let mut tw = TabWriter::new(io::stderr());
    writeln!(tw,"suite\ttarget\tmin\t95%\t75%\tmean\tmax\tstddev\tsamples ({}/{})", std::cmp::min(runs,samples), runs).unwrap();
    for (key,vals) in times {
        let ss: SummStats = vals.iter().cloned().collect();
        let mut pc: Percentiles = vals.iter().cloned().collect();
        writeln!(tw, "{}\t{}\t{:.0}\t{:.0}\t{:.0}\t{}\t{:.0}\t{}", key,
                 ss.min().unwrap(),
                 pc.percentile(&0.95).unwrap(),
                 pc.percentile(&0.75).unwrap(),
                 ss.mean().unwrap(),
                 ss.max().unwrap(),
                 ss.standard_deviation().unwrap_or(0.0),
                 vals.iter().take(samples).map(|f| f.to_string()).collect::<Vec<String>>().join(",")).unwrap();
    }
    tw.flush().unwrap();
}
